"""
Code Generator - Generates intermediate representation or target code
Converts AST to executable or analyzable code representation.
"""

from typing import List, Dict, Any
from ast_nodes import *


class VerilogCodeGenerator(ASTVisitor):
    """Generates intermediate representation from Verilog AST."""
    
    def __init__(self):
        self.output = []
        self.indent_level = 0
        self.current_module = None
        
        # Statistics and analysis
        self.stats = {
            'modules': 0,
            'ports': 0,
            'wires': 0,
            'regs': 0,
            'assigns': 0,
            'always_blocks': 0
        }
        
        # Generated IR components
        self.ir_components = {
            'modules': [],
            'signals': [],
            'combinational_logic': [],
            'sequential_logic': [],
            'statements': [],
            'instantiations': []
        }
    
    def generate(self, ast: ModuleNode) -> str:
        """
        Generate code from AST.
        
        Args:
            ast (ModuleNode): Root AST node
            
        Returns:
            str: Generated code representation
        """
        self.output = []
        self.indent_level = 0
        
        # Generate header
        self._emit("// Generated by Verilog Compiler")
        self._emit("// Intermediate Representation")
        self._emit("")
        
        # Visit AST
        ast.accept(self)
        
        # Generate statistics
        self._emit("")
        self._emit("// Compilation Statistics:")
        for key, value in self.stats.items():
            self._emit(f"// {key}: {value}")
        
        # Generate IR summary
        self._emit("")
        self._emit("// Intermediate Representation Summary:")
        self._generate_ir_summary()
        
        return "\n".join(self.output)
    
    def _emit(self, code: str = ""):
        """Emit a line of code with proper indentation."""
        if code:
            self.output.append("  " * self.indent_level + code)
        else:
            self.output.append("")
    
    def _indent(self):
        """Increase indentation level."""
        self.indent_level += 1
    
    def _dedent(self):
        """Decrease indentation level."""
        self.indent_level = max(0, self.indent_level - 1)
    
    def visit_module(self, node: ModuleNode):
        self.current_module = node.name
        self.stats['modules'] += 1
        
        self._emit(f"MODULE {node.name} {{")
        self._indent()
        
        # Record module in IR
        module_ir = {
            'name': node.name,
            'ports': [port.name for port in node.ports],
            'type': 'module'
        }
        self.ir_components['modules'].append(module_ir)
        
        # Process ports
        if node.ports:
            self._emit("// Port Declarations")
            for port in node.ports:
                port.accept(self)
            self._emit("")
        
        # Process module items
        if node.items:
            self._emit("// Module Body")
            for item in node.items:
                item.accept(self)
        
        self._dedent()
        self._emit("}")
        
        return ""
    
    def visit_port(self, node: PortNode):
        direction = node.direction if node.direction else "inout"
        self._emit(f"PORT {direction.upper()} {node.name};")
        self.stats['ports'] += 1
        
        # Record signal in IR
        signal_ir = {
            'name': node.name,
            'type': 'port',
            'direction': direction,
            'module': self.current_module
        }
        self.ir_components['signals'].append(signal_ir)
        
        return ""
    
    def visit_port_declaration(self, node: PortDeclarationNode):
        range_str = ""
        if node.range_spec:
            msb = node.range_spec.msb.accept(self)
            lsb = node.range_spec.lsb.accept(self)
            range_str = f"[{msb}:{lsb}] "
        
        for name in node.names:
            self._emit(f"PORT_DECL {node.direction.upper()} {range_str}{name};")
            self.stats['ports'] += 1
            
            # Record signal in IR
            signal_ir = {
                'name': name,
                'type': 'port',
                'direction': node.direction,
                'range': range_str.strip() if range_str else None,
                'module': self.current_module
            }
            self.ir_components['signals'].append(signal_ir)
        
        return ""
    
    def visit_net_declaration(self, node: NetDeclarationNode):
        range_str = ""
        if node.range_spec:
            msb = node.range_spec.msb.accept(self)
            lsb = node.range_spec.lsb.accept(self)
            range_str = f"[{msb}:{lsb}] "
        
        for name in node.names:
            self._emit(f"NET_DECL {node.net_type.upper()} {range_str}{name};")
            
            if node.net_type == 'wire':
                self.stats['wires'] += 1
            elif node.net_type == 'reg':
                self.stats['regs'] += 1
            
            # Record signal in IR
            signal_ir = {
                'name': name,
                'type': node.net_type,
                'range': range_str.strip() if range_str else None,
                'module': self.current_module
            }
            self.ir_components['signals'].append(signal_ir)
        
        return ""
    
    def visit_range(self, node: RangeNode):
        msb = node.msb.accept(self)
        lsb = node.lsb.accept(self)
        return f"[{msb}:{lsb}]"
    
    def visit_assign(self, node: AssignNode):
        target = node.target.accept(self)
        source = node.source.accept(self)
        self._emit(f"ASSIGN {target} = {source};")
        self.stats['assigns'] += 1
        
        # Record combinational logic in IR
        logic_ir = {
            'type': 'assign',
            'target': target,
            'source': source,
            'module': self.current_module
        }
        self.ir_components['combinational_logic'].append(logic_ir)
        
        return ""
    
    def visit_always(self, node: AlwaysNode):
        sens_list = ", ".join(node.sensitivity_list) if node.sensitivity_list else "*"
        self._emit(f"ALWAYS @({sens_list}) {{")
        self._indent()
        
        node.statement.accept(self)
        
        self._dedent()
        self._emit("}")
        self.stats['always_blocks'] += 1
        
        # Record sequential logic in IR
        logic_ir = {
            'type': 'always',
            'sensitivity_list': node.sensitivity_list,
            'module': self.current_module
        }
        self.ir_components['sequential_logic'].append(logic_ir)
        
        return ""
    
    def visit_initial(self, node):
        self._emit("INITIAL {")
        self._indent()
        
        node.statement.accept(self)
        
        self._dedent()
        self._emit("}")
        
        self.stats.setdefault('initial_blocks', 0)
        self.stats['initial_blocks'] += 1
        
        # Record in IR
        initial_ir = {
            'type': 'initial_block',
            'module': self.current_module
        }
        self.ir_components['statements'].append(initial_ir)
        
        return ""
    
    def visit_delay(self, node):
        self._emit(f"DELAY #{node.delay}")
        if node.statement:
            node.statement.accept(self)
        
        return ""
    
    def visit_forever(self, node):
        self._emit("FOREVER {")
        self._indent()
        
        if node.statement:
            node.statement.accept(self)
        
        self._dedent()
        self._emit("}")
        
        return ""
    
    def visit_system_task(self, node):
        args_str = ""
        if node.args:
            arg_values = [arg.accept(self) for arg in node.args]
            args_str = f"({', '.join(arg_values)})"
        
        self._emit(f"SYSTEM_TASK {node.task_name}{args_str};")
        
        return ""
    
    def visit_block(self, node: BlockNode):
        self._emit("BEGIN")
        self._indent()
        
        for stmt in node.statements:
            stmt.accept(self)
        
        self._dedent()
        self._emit("END")
        
        return ""
    
    def visit_if(self, node: IfNode):
        condition = node.condition.accept(self)
        self._emit(f"IF ({condition}) {{")
        self._indent()
        
        node.then_stmt.accept(self)
        
        self._dedent()
        if node.else_stmt:
            self._emit("}} ELSE {{")
            self._indent()
            node.else_stmt.accept(self)
            self._dedent()
        
        self._emit("}")
        
        return ""
    
    def visit_assignment(self, node: AssignmentNode):
        target = node.target.accept(self)
        source = node.source.accept(self)
        self._emit(f"{target} {node.operator} {source};")
        
        return ""
    
    def visit_binary_op(self, node: BinaryOpNode):
        left = node.left.accept(self)
        right = node.right.accept(self)
        
        # Convert Verilog operators to IR representation
        op_map = {
            '&': 'AND',
            '|': 'OR',
            '^': 'XOR',
            '~': 'NOT'
        }
        
        op = op_map.get(node.operator, node.operator)
        return f"({left} {op} {right})"
    
    def visit_unary_op(self, node: UnaryOpNode):
        operand = node.operand.accept(self)
        
        # Convert Verilog operators to IR representation
        op_map = {
            '~': 'NOT'
        }
        
        op = op_map.get(node.operator, node.operator)
        return f"{op}({operand})"
    
    def visit_identifier(self, node: IdentifierNode):
        return node.name
    
    def visit_number(self, node: NumberNode):
        return node.value
    
    def visit_string(self, node):
        return node.value
    
    def visit_index(self, node: IndexNode):
        """Visit single bit index node."""
        identifier = node.identifier.accept(self)
        index = node.index.accept(self)
        return f"{identifier}[{index}]"
    
    def visit_index_range(self, node: IndexRangeNode):
        """Visit bit range index node."""
        identifier = node.identifier.accept(self)
        msb = node.msb.accept(self)
        lsb = node.lsb.accept(self)
        return f"{identifier}[{msb}:{lsb}]"
    
    def visit_module_instantiation(self, node: ModuleInstantiationNode):
        """Visit module instantiation node."""
        self._emit(f"INSTANCE {node.module_type} {node.instance_name} (")
        self._indent()
        
        for i, conn in enumerate(node.connections):
            conn_str = conn.accept(self)
            comma = "," if i < len(node.connections) - 1 else ""
            self._emit(f"{conn_str}{comma}")
        
        self._dedent()
        self._emit(");")
        
        # Record instance in IR
        instance_ir = {
            'module_type': node.module_type,
            'instance_name': node.instance_name,
            'connections': [{'port': conn.port_name, 'signal': conn.signal.accept(self)} for conn in node.connections],
            'module': self.current_module
        }
        self.ir_components['instantiations'].append(instance_ir)
        
        return ""
    
    def visit_port_connection(self, node: PortConnectionNode):
        """Visit port connection node."""
        signal = node.signal.accept(self)
        return f".{node.port_name}({signal})"
    
    def _generate_ir_summary(self):
        """Generate a summary of the intermediate representation."""
        self._emit("// Signal Declarations:")
        for signal in self.ir_components['signals']:
            range_info = f" {signal['range']}" if signal.get('range') else ""
            direction_info = f" {signal.get('direction', '')}" if signal.get('direction') else ""
            self._emit(f"//   {signal['name']}: {signal['type']}{direction_info}{range_info}")
        
        if self.ir_components['combinational_logic']:
            self._emit("// Combinational Logic:")
            for logic in self.ir_components['combinational_logic']:
                self._emit(f"//   {logic['target']} = {logic['source']}")
        
        if self.ir_components['sequential_logic']:
            self._emit("// Sequential Logic:")
            for logic in self.ir_components['sequential_logic']:
                sens = ", ".join(logic['sensitivity_list']) if logic['sensitivity_list'] else "*"
                self._emit(f"//   always @({sens})")
    
    def get_ir_data(self) -> Dict[str, Any]:
        """
        Get the intermediate representation data structure.
        
        Returns:
            Dict[str, Any]: IR components and statistics
        """
        return {
            'components': self.ir_components,
            'statistics': self.stats,
            'module': self.current_module
        }
    
    def generate_verilog_output(self, ast: ModuleNode) -> str:
        """
        Generate cleaned Verilog output (code beautification).
        
        Args:
            ast (ModuleNode): Root AST node
            
        Returns:
            str: Beautified Verilog code
        """
        output = []
        
        def emit(code: str, indent: int = 0):
            if code.strip():
                output.append("  " * indent + code)
            else:
                output.append("")
        
        # Generate beautified Verilog
        emit(f"module {ast.name}", 0)
        
        # Ports
        if ast.ports:
            port_list = ", ".join([port.name for port in ast.ports])
            emit(f"  ({port_list});", 0)
        else:
            emit("  ();", 0)
        
        emit("")
        
        # Module body
        for item in ast.items:
            if isinstance(item, PortDeclarationNode):
                range_str = ""
                if item.range_spec:
                    msb = item.range_spec.msb.accept(self)
                    lsb = item.range_spec.lsb.accept(self)
                    range_str = f"[{msb}:{lsb}] "
                
                names = ", ".join(item.names)
                emit(f"  {item.direction} {range_str}{names};", 0)
            
            elif isinstance(item, NetDeclarationNode):
                range_str = ""
                if item.range_spec:
                    msb = item.range_spec.msb.accept(self)
                    lsb = item.range_spec.lsb.accept(self)
                    range_str = f"[{msb}:{lsb}] "
                
                names = ", ".join(item.names)
                emit(f"  {item.net_type} {range_str}{names};", 0)
            
            elif isinstance(item, AssignNode):
                target = item.target.accept(self)
                source = item.source.accept(self)
                emit(f"  assign {target} = {source};", 0)
        
        emit("")
        emit("endmodule")
        
        return "\n".join(output)
